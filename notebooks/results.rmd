---
title: "Fault Detection Modeling"
author: Alexander Nielsen
date: January 23, 2026
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
```

## Packages

```{r packages}
pkgs <- c(
  "tidyverse",
  "lme4",
  "readr",
  "broom.mixed",
  "sjPlot",
  "emmeans",
  "ggplot2",
  "ggeffects",
  "marginaleffects",
  "devtools",
  "scales",
  "kableExtra"
)

to_install <- pkgs[!pkgs %in% rownames(installed.packages())]
if (length(to_install) > 0) install.packages(to_install)

invisible(lapply(pkgs, library, character.only = TRUE))
```

## Load data

```{r data-load}
csv_path <- "../data/results-2026-01-23-115413/results.csv"

d_raw <- readr::read_csv(csv_path, show_col_types = FALSE)
d_raw
```

## Prepare data

```{r data-prep}
eps <- 1e-6

df <- d_raw %>%
  mutate(
    # Ensure types
    total_faults    = as.integer(total_faults),
    faults_detected = as.integer(faults_detected),
    n_total_tests   = as.integer(n_total_tests),

    # Derived columns
    failures = as.integer(total_faults - faults_detected),
    prop     = as.numeric(faults_detected / total_faults),
    budget   = as.numeric(budget_prop_achieved),
    budget_n   = (budget - 0.1) * 100,
    budget_f   = factor(budget_prop_requested),

    # Logit transform of budget (bounded away from 0/1)
    p              = pmin(pmax(budget, eps), 1 - eps),
    budget_logit   = as.numeric(qlogis(p)),

    # Factors
    program          = factor(program),
    language         = relevel(factor(language), ref = "C"),
    algorithm_family = relevel(factor(algorithm_family), ref = "cs"),
    representation   = relevel(factor(representation), ref = "tf_srp"),

    # Paired-trial identifier: all methods share same (language, random_seed)
    trial_id = interaction(language, random_seed, drop = TRUE)
  ) %>%
  filter(
    !is.na(total_faults),
    !is.na(faults_detected),
    total_faults >= 0,
    faults_detected >= 0,
    faults_detected <= total_faults,
    representation != "SuiteLength"
  )

df
```

## Models

### No interaction model

Hypothesis: Budget effect is non-linear

```{r budget-linear}
budget_linear <- glmer(
  cbind(faults_detected, failures) ~
    algorithm_family + representation + budget + language +
    (1 | test_suite / run_id),
  family = binomial(link = "logit"),
  data = df
)
```

```{r budget-quad}
budget_quad <- glmer(
  cbind(faults_detected, failures) ~
    algorithm_family + representation + (budget + I(budget^2)) + language +
    (1 | test_suite / run_id),
  family = binomial(link = "logit"),
  data = df
)
```

```{r budget-logit}
budget_logit <- glmer(
  cbind(faults_detected, failures) ~
    algorithm_family + representation + budget_logit + language +
    (1 | test_suite / run_id),
  family = binomial(link = "logit"),
  data = df
)
```


#### Test of budget linear vs non-linear

```{r anova-budget}
anova(budget_linear, budget_quad, test = "Chisq")
AIC(budget_linear, budget_quad, budget_logit)
BIC(budget_linear, budget_quad, budget_logit)
```

Quadratic budget model is not significantly better than linear budget model. However, the logit budget model is strongly preferred by both AIC and BIC. Therefore, we will use the
logit budget model for further modeling.


### Final model

```{r final-model}
m <- glmer(
  cbind(faults_detected, failures) ~
    representation * algorithm_family +
    budget_logit + 
    language + 
    (1 | test_suite / run_id),
  family = binomial,
  data = df
)

anova(budget_logit, m, test = "Chisq")
```


### Overdispersion check

```{r overdispersion-check}
overdisp_fun <- function(model) {
  rdf <- df.residual(model)
  rp <- residuals(model, type = "pearson")
  sqrt(sum(rp^2) / rdf)
}

overdisp_fun(m)
```


### Final model estimated marginal means

```{r emmeans}
emm <- emmeans(m, ~ representation * algorithm_family | language, type = "response")
pairs(emm, adjust = "holm")
```



### Final model summary

```{r final-model-summary}
summary(m)
```


```{r table}
fixed_effects_table <- tidy(
  m,
  effects = "fixed",
  conf.int = TRUE,
  conf.method = "Wald"
) %>%
  mutate(
    odds_ratio = exp(estimate),
    conf.low.or = exp(conf.low),
    conf.high.or = exp(conf.high)
  ) %>%
  select(
    term,
    estimate,
    std.error,
    odds_ratio,
    conf.low.or,
    conf.high.or,
    p.value
  )

fixed_effects_table

tab <- fixed_effects_table %>%
  mutate(
    estimate    = round(estimate, 3),
    std.error   = round(std.error, 3),
    odds_ratio  = round(odds_ratio, 3),
    conf.low.or = round(conf.low.or, 3),
    conf.high.or= round(conf.high.or, 3),
    p.value     = format.pval(p.value, digits = 3, eps = 0.001)
  ) %>%
  rename(
    Term = term,
    `Log-odds` = estimate,
    `SE` = std.error,
    `OR` = odds_ratio,
    `CI low` = conf.low.or,
    `CI high` = conf.high.or,
    `p` = p.value
  )

kable(tab, format = "latex", booktabs = TRUE,
      caption = "GLMM fixed effects (odds ratios with 95\\% CI).") %>%
  kable_styling(latex_options = c("hold_position"))
```